env SuperInertiacEntity as Level

use Pewpew
use FmathHelpers
use ShipEntity

pub entity SuperInertiac {
  fixed x, y = 0f, 0f
  fixed velX, velY = 0f, 0f
  fixed acceleration = 2f
  fixed dashSpeed = 2f

  number hitCooldownTimer

  number dashCooldown
  number dashPraparationTimer
  bool isPreparingDash

  number health = 70

  bool canHit

  bool isDead
  
  number frameOffset = 0
  number maxFrames = 60
  list<number> frames

  fixed ringAmount = 3f
  list<entity> rings
  list<struct{fixed x, y, z}> axises

  fixed predictionSpeed = 0.65f
  entity predictionLine
  fixed pdX, pdY

  number time
  number reactionTime = 4
  bool hit

  fixed radius = 25f

  spawn(fixed x, fixed y) {
    SpawnEntity(self, 60)
    SetEntityInterpolation(self, true)

    SetEntityPosition(self, x, y)

    //SetEntityColor(self, 0x00ffffff)
    SetEntityMesh(self, SPAnim, 0)
    SetEntityRadius(self, radius)
    
    predictionLine = NewEntity(x, y)
    SetEntityMesh(predictionLine, SPPredLineMesh, 1)
    SetEntityInterpolation(predictionLine, true)

    Table:Insert(frames, 0)

    repeat from ringAmount to 1f by -1f with i {
      entity ring = NewEntity(x, y)
      Table:Insert(rings, ring)
      fixed t = InvLerp(4f, 1f, i)
      SetEntityMeshScale(ring, t)
      SetEntityMesh(ring, SPAnim, 0)
      SetEntityInterpolation(ring, true)
      //SetEntityColor(ring, ColorHelpers:MakeColor(Fmath:ToNum(100 * t), Fmath:ToNum(255 * t), 255, 200))
      Table:Insert(axises, struct{
        x, y, z = Fmath:RandomFixed(-1f, 1f), Fmath:RandomFixed(-1f, 1f), Fmath:RandomFixed(-0.3f, 0.3f)
      })
      Table:Insert(frames, Fmath:RandomNum(0, 59))
    }
  }

  destroy() {
    isDead = true
    canHit = false
    hitCooldownTimer = 999999999
    
    PlaySound(SPSound, 0, x, y)
    SetEntityWallCollision(self, false)
    ExplodeEntity(self, 20)
    CreateExplosion(x, y, 0x1144aaff, 1.6f, 50)
    CreateExplosion(x, y, 0x330077ff, 1.6f, 50)
    CreateExplosion(x, y, 0x00aaddff, 1.6f, 50)

    for i, v in rings{
      ExplodeEntity(rings[i], 20)
    }

    ExplodeEntity(predictionLine, 0)
  }

  WallCollision(fixed normalX, fixed normalY) {
    if isDead 
      return 
    
    if !IsEntityAlive(SHIP.id) 
      velX, velY *= 0.7f, 0.7f

    velX, velY = Reflect(velX, velY, normalX, normalY)
  }
  
  PlayerCollision(number playerIndex, entity shipId) {
    if IsEntityAlive(shipId) and canHit {
      velX, velY = -velX * 1.5f, -velY * 1.5f
      DamageShip(shipId, 1)

      health = MathHelper:Clamp(health + 10, 0, 70)

      CreateExplosion(x, y, 0x1144aaff, 0.8f, 10)
      CreateExplosion(x, y, 0x330077ff, 0.8f, 10)
      CreateExplosion(x, y, 0x00aaddff, 0.8f, 10)
    }

    canHit = false
  }

  fn Bounce(entity e, fixed intensity) {
    if IsEntityAlive(e) {
      fixed sX, sY = GetEntityPosition(e) 
      fixed dX, dY = Normalize(x - sX, y - sY)
      velX, velY += dX * intensity, dY * intensity
    }
  }

  WeaponCollision(number playerIndex, WeaponType weaponType) -> bool {
    if isDead 
      return false

    if weaponType == WeaponType.Bullet {
      health -= 1
      if health > 0 {
        Bounce(SHIP.id, 1.1f)

        hit = true
        PlaySound(SPSound, 1+health, x, y)
      }

      CreateExplosion(x, y, 0x1144aaff, 0.8f, 10)
      CreateExplosion(x, y, 0x330077ff, 0.8f, 10)
      CreateExplosion(x, y, 0x00aaddff, 0.8f, 10)
    }
    
    if health <= 0 {
      destroy self()
    }
  
    return true
  }

  Update() {
    x, y = GetEntityPosition(self)

    UpdateCooldown()
  
    Move()

    x, y = GetEntityPosition(self)

    if !isDead {
      let entities = GetEntitiesCollidingWithDisk(x, y, radius)
      for i, v in entities {
        if v == self {
          continue
        }
        if converted = v is SuperInertiac and IsEntityAlive(v) {
          if converted.isDead {
            continue
          }
          if Length(converted.velX, converted.velY) > Length(velX, velY) {
            Bounce(converted, 1.2f)
            destroy converted()
            continue
          }
          continue
        }
        EntityReactToWeapon(v, struct{ // if quadro is Quadro
          type = WeaponType.Bullet; // if Pewpew:GetCustomizableEntityType(quadro) == Quadro { } 
          x = velX;
          y = velY;
          player_index = -1
        })
      }
    }
    if dashPraparationTimer <= 0 {
      isPreparingDash = false
      dashPraparationTimer = 25
      Dash()
    }

    UpdatePredicitonLine()
    UpdateVisuals()
  }

  fn Move() {
    fixed length = 1f

    if !isDead and IsEntityAlive(SHIP.id) and !isPreparingDash {
      fixed sX, sY = GetEntityPosition(SHIP.id) 
      fixed dX, dY = Normalize(sX - x, sY - y)

      velX += dX * 1.7f
      velY += dY * 1.7f
      velX, velY *= 0.95f, 0.95f
    } else if isDead or !IsEntityAlive(SHIP.id) or isPreparingDash {
      velX, velY *= 0.80f, 0.80f
    }

    x, y += velX, velY
    SetEntityPosition(self, x, y)
    for i, _ in rings {
        fixed r1x, r1y = GetEntityPosition(rings[i])
        fixed fixedI = Fmath:ToFixed(i)
        //Print(fixedI)
        fixed fixedT = Lerp(0.2f, 1f, InvLerp(1f, 3f, fixedI))
        if fixedT < 0.5f {
          //fixedT = Fmath:Sqrt(fixedT)
        }else {
          fixedT *= fixedT
        }
        SetEntityPosition(rings[i], Lerp(r1x, x, fixedT), Lerp(r1y, y, fixedT))
      }
    if !isDead {
      SetEntityPosition(predictionLine, x, y)
    }
  }

  fn Dash() {
    //fixed pDY, pDX = GetPlayerMovementPrediction()

    if isDead or !IsEntityAlive(SHIP.id) 
      return 

    velX = pdX * 40f
    velY = pdY * 40f

    SetEntityMesh(predictionLine, SPPredLineMesh, 1)
    CreateExplosion(x, y, 0x1144aaff, 1f, 20)
    CreateExplosion(x, y, 0x330099ff, 1f, 20)
    CreateExplosion(x, y, 0x0044aaff, 1f, 20)
  }

  fn UpdateCooldown() {
    if !canHit 
      hitCooldownTimer -= 1
    
    if hitCooldownTimer <= 0 and !canHit {
      hitCooldownTimer = 10
      canHit = true
    }

    if !isPreparingDash
      dashCooldown -= 1

    if dashCooldown <= 0 and !isPreparingDash {
      isPreparingDash = true
      dashCooldown = 90
    }

    if isPreparingDash and !isDead {
      SetEntityMesh(predictionLine, SPPredLineMesh, 0)
      dashPraparationTimer -= 1
    }
  }

  fn UpdateVisuals() {
    if hit {
      frameOffset = 60
      time += 1
      if time >= reactionTime {
        hit = false
        time = 0
        frameOffset = 0
      }
    }

    fixed magnitude = Length(velX, velY) * 0.02f

    // if magnitude == 0f 
    //   return

    RotateEntityMesh(self, magnitude*magnitude + 0.1f, Fmath:RandomFixed(0f, 1f), Fmath:RandomFixed(0f, 1f), 0f)
    
    if !isDead {
      frames[1] += 1 
      frames[1] = MathHelper:Wrap(frames[1], 0, 59)
    }
    
    SetEntityFlippingMeshes(self, SPAnim, frames[1] % maxFrames + frameOffset, MathHelper:Wrap(frames[1] % maxFrames + 1 + frameOffset, frameOffset, 59+frameOffset))
    for i in rings {
      SetEntityFlippingMeshes(rings[i], SPAnim, frames[i+1] % maxFrames + frameOffset, MathHelper:Wrap(frames[i+1] % maxFrames + 1 + frameOffset, frameOffset, 59+frameOffset))
      RotateEntityMesh(rings[i], magnitude*magnitude + 0.1f, axises[i].x, axises[i].y, 0f)
      if !isDead {
        frames[i+1] += 1
        frames[1] = MathHelper:Wrap(frames[1], 0, 59)
      }
    }
  }

  fn UpdatePredicitonLine() {
    //fixed pDY, pDX = GetPlayerMovementPrediction()
    if isDead or !IsEntityAlive(SHIP.id) 
      return 

    fixed sX, sY = GetEntityPosition(SHIP.id)
    fixed dX, dY = sX - x, sY - y
    fixed sMovAngle, sMovDist, _, _ = GetPlayerInputs(0) 

    fixed mag = Length(dX, dY)
    fixed sMovDY, sMovDX = Fmath:Sincos(sMovAngle)
    fixed predMovX, predMovY = sMovDX * sMovDist * 100f, sMovDY * sMovDist * 100f
    predMovX, predMovY = -predMovX, -predMovY

    fixed pDX, pDY = Normalize((dX - predMovX - velX), (dY - predMovY - velY)) 
    pdX = Lerp(pdX, pDX, predictionSpeed)
    pdY = Lerp(pdY, pDY, predictionSpeed)

    SetEntityMeshAngle(predictionLine, Fmath:Atan2(pdY, pdX), 0f, 0f, 1f)
  }
}