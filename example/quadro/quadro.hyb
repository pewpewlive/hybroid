env QuadroEntity as Level

use Pewpew
use FmathHelpers

pub entity Quadro {
  fixed x, y = 0f, 0f
  fixed velX, velY = 0.01f, 0.01f
  fixed speed = 5f

  number hitCooldownTimer

  number health = 5

  entity ship
  bool canHit

  bool isDead

  spawn(fixed x, fixed y, entity ship) {
    self.ship = ship

    SetEntityInterpolation(self, true)

    SetEntityPosition(self, x, y)

    SetEntityMesh(self, QuadroMesh, 0)
    SetEntityRadius(self, 15f)
  }

  destroy() {
    PlaySound(QuadroSound, 1, x, y)
    ExplodeEntity(self, 10)
  }

  WallCollision(fixed normalX, fixed normalY) {
    /*
      dirToCenter = Vector2(self.position.x - width/2,self.position.y - height/2)

      v = math.sqrt(self.velocity.x * self.velocity.x + self.velocity.y * self.velocity.y)
      angleToCollisionPoint = math.atan2(-dirToCenter.y,dirToCenter.x)
      oldAngle = math.atan2(-self.velocity.y,self.velocity.x)
      newAngle = 2 * angleToCollisionPoint - oldAngle
      self.velocity = Vector2(-v * math.cos(newAngle),v * math.sin(newAngle))
    */
    velX = -velX * 0.8f
    velY = -velY * 0.8f

    fixed len = Length(velX, velY)

    fixed normalAngle = Fmath:Atan2(-normalY, normalX)
    fixed oldAngle = Fmath:Atan2(-velX, velY)
    fixed newAngle = 2f * normalAngle - oldAngle

    velY, velX = Fmath:Sincos(newAngle)
    velY, velX *= len, len
  }
  
  PlayerCollision(number playerIndex, entity shipId) {
    if IsEntityAlive(shipId) and canHit {
      DamageShip(shipId, 1)
    }

    canHit = false
  }

  WeaponCollision(number playerIndex, WeaponType weaponType) -> bool {
    if isDead 
      return false

    if weaponType == WeaponType.Bullet {
      health -= 1
      if health > 0 {
        PlaySound(QuadroSound, 0, x, y)
      }
    }
    
    if health <= 0 {
      isDead = true
      canHit = false
      destroy self()
    }

    return true
  }

  Update() {
    x, y = GetEntityPosition(self)

    UpdateCooldown()

    Move()
  }

  fn Move() {
    if !isDead and IsEntityAlive(ship) {
      fixed sX, sY = GetEntityPosition(ship) 

      fixed length = Length(sX - x, sY - y) * 0.002f
      length *= length
      Print(length)

      fixed dirX, dirY = Normalize(sX - x, sY - y)
      
      velX += dirX * length
      velY += dirY * length

      velX, velY = Clamp(velX, -speed, speed), Clamp(velY, -speed, speed)
    }

    SetEntityPosition(self, x + velX, y + velY)
  }

  fn UpdateCooldown() {
    hitCooldownTimer -= 1
    
    if hitCooldownTimer <= 0 {
      hitCooldownTimer = 10
      canHit = true
    }
  }
}