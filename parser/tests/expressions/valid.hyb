let a = 1
let b = [1,2,3]
let c = {a = {b = fn() -> number => 2}}
let d = struct{a = 1; b = 2; c = 3}
let e = true
let f = false
let g = !true
let g2 = !!!!false
let h = -1
let i = fn() {}
let j = fn() -> number => 2
let k = fn(fixed param) -> bool {
    return false
}
let l = fn() -> (text, list<bool>) {
    return "a", [false, true]
}
let m = fn() -> fn() -> fn() {
    return fn() -> fn() {
        return fn() {
        }
    }
}
let n = [
    fn(number a, fixed b) -> bool {
        return false
    },
    fn(number a, fixed b) -> bool => true
]
let o = "string"

enum EnumTest {
    One,
    Two,
    Three,
    Four
}

class Test {
    number a = 1
    fixed b = 2f
    EnumTest c = EnumTest.Four

    new() {}

    fn method(struct{number field1, bool field2, EnumTest field3} param1) -> bool {
        return false
    }

    fn method1(bool... param1) -> bool {
        return false
    }
}

let p = new Test()
let q = p.a
let r = p.b
let s = p.method(struct{field1 = 1; field2 = true; field3 = EnumTest.One})
let t = b[1]
let u = c["a"]["b"]()
let v = {
    a = [struct{field = [new Test(), new Test()]; field2 = 2d}]
}
let x = v["a"].field[2].c

entity EntityTest {
    text a = ""
    Test b = new Test()

    fn test((bool, bool) thing) -> Env:Type {
        thing, a = b == 4, a == ""
    }

    spawn(fixed x, fixed y) {}

    destroy() {}
}

let y = [
    struct{
        a = [
            spawn EntityTest(10f, 10f),
        ]
    }
]

let z = y[1].a[2].b.method1(false, true)
let za = v[1]["a"].call()[0].field["a"]()

alias zb = number
alias zc = list<number>
alias p = (number, list<number>, zb)
alias e = struct{WeaponType a, bool b, p i}
alias Alias = fn(number, Thing:Type) -> entity
enum O {
    Field1,
    Field2,
    Field3,
    Field4,
}
fn function(fixed param1, param2, Type2 param3) -> fn() -> (bool, bool) {
    fixed u = 1+param1
}