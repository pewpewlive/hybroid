env Graphix as Mesh

use Table

pub fn NewMesh() -> Mesh {
  return struct{
    Vertexes vertexes;
    Segments segments;
    Colors colors;
  }
}

pub fn Scale(Mesh mesh, number modifier) {
  for _, v in mesh.vertexes {
    for i, _ in v {
      v[i] *= modifier
    }
  }
}

pub fn ScaleAxis(Mesh mesh, Vertex mods) {
  for _, v in mesh.vertexes {
    for i, _ in v {
      if #mods < i {
        continue
      }
      v[i] *= mods[i]
    }
  }
}

pub fn AddLine(Mesh mesh, Vertexes vertexes, Colors colors, bool closeLoop) {
  let vertexCount = #mesh.vertexes
  let colorCount = #mesh.colors
  let segmentCount = #mesh.segments

  let numberOfNewSegments = #vertexes - 1
  let Segment segment = []
  
  repeat with i to #vertexes {
    Insert(mesh.vertexes, vertexes[i])
    Insert(mesh.colors, colors[i])
  }

  Insert(segment, vertexCount)
  repeat with i to numberOfNewSegments {
    Insert(segment, vertexCount + i)
  }

  if closeLoop {
    Insert(segment, vertexCount)
  }
  Insert(mesh.segments, segment)
}

pub fn AddFlatPoly(Mesh mesh, Vertex center, number sides, color, radius, startAngle) {
  if sides <= 2
    return

  let Vertexes vertexes 
  let Colors colors

  let number z
  if #center >= 3 {
    z = center[3]
  }

  repeat sides with i {
    let angle = (Math:Pi * 2 * i) / sides + startAngle
    Insert(vertexes, [center[1] + radius * Math:Cos(angle), center[2] + radius * Math:Sin(angle), z])
    Insert(colors, color)
  }

  AddLine(mesh, vertexes, colors, true)
}

pub fn AddStar(Mesh mesh, Vertex center, number sides, color, insetColor, radius, insetRadius, startAngle) {
  if sides <= 2
    return

  sides *= 2

  let Vertexes vertexes 
  let Colors colors

  let number x = center[1]
  let number y = center[2]
  let number z
  if #center >= 3 {
    z = center[3]
  }

  let number currentRadius
  let number currentColor

  repeat sides with i {
    if i % 2 == 0 {
      currentRadius = insetRadius
      currentColor = insetColor
    }
    else {
      currentRadius = radius
      currentColor = color
    } 

    let angle = (Math:Pi * 2 * i) / sides + startAngle
    Insert(vertexes, [x + currentRadius * Math:Cos(angle), y + currentRadius * Math:Sin(angle), z])
    Insert(colors, currentColor)
  }

  AddLine(mesh, vertexes, colors, true)
}
