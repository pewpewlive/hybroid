env ExpressionsText as Level

enum EnumTest {
    One,
    Two,
    Three,
    Four
}

fn returnTest() {
    if true
        return

    let cool = 0
}

class Test {
    number a = 1
    fixed b = 2f
    EnumTest c = EnumTest.Four
    Test test// = new Test()
    list<list<struct{Test xd, fn() -> Test s}>> tests = [[struct{ xd = new Test(); s = fn() -> Test { 
        return new Test()
    } }]]
    fn() -> Test bizhhh = fn() -> Test { 
        return new Test()
    }

    new() {
        test = self
    }

    fn method(struct{number field1, bool field2, EnumTest field3} param1) -> bool {
        return false
    }

    fn method1(bool... param1) -> bool {
        return false
    }

    fn method3() -> Test {
        return self        
    }
    fn method2() -> list<list<map<Test>>> {
        return tests      
    }
    fn method4() -> fn() -> Test {
        return fn() -> Test {
            return self
        } 
    }
}

let p = new Test()// variable: classVal
Test asdasdads = p.test // variable: variable: classVal

Test assddxxx = p // variable: variable: classVal
EnumTest enumsss = asdasdads.c // 
EnumTest enumss = p.test.c

let asdsss = p.test.tests[0][0]
//[4][5][0][0]["xd"]
bool bizh = p.method2()[0][0].xd.method3().method3().test.tests[0][0].xd.method2()[0][0].xd.method3().method3().method(struct{
    field1, field2, field3 = 1, true, EnumTest.One
})

fn function(EnumTest param) {
    if param == EnumTest.One {

    }
}

entity sadfsadgf
entity aasd {
    spawn(fixed x, fixed y) {}
    destroy() {}
}
entity aasd12 = Pewpew:NewEntity(0f, 0f)

fn(fixed, number) adf

let a = 1
let b = [1,2,3]
list<fixed> asdsdssdds = [2f, 3f, 4f]
let c = {a = {b = fn() -> number => 2}}
let d = struct{a = 1; b = 2; c = 3}
const e = true
pub bool f = false
pub g = !true
bool g2 = !!!!false
const number h = -1
let i = fn() {}
let j = fn() -> number => 2
let k = fn(fixed param) -> bool {
    return false
}
let l = fn() -> (text, list<bool>) {
    return "a", [false, true]
}
let m = fn() -> fn() -> fn() {
    return fn() -> fn() {
        return fn() {
        }
    }
}
let n = [
    fn(number a, fixed b) -> bool {
        return false
    },
    fn(number a, fixed b) -> bool => true
]
let o = "string"


let q = p.a
let r = p.b
let s = p.method(struct{field1 = 1; field2 = true; field3 = EnumTest.One})
let t = b[1]
let u = c["a"]["b"]()
let v = {
    a = [struct{field = [new Test(), new Test()]; field2 = 2d}]
}

EnumTest aasdsad = EnumTest.One
if aasdsad == EnumTest.One {

}


// let x = v["a"].field[2].c

// entity EntityTest {
//     text a = ""
//     Test b = new Test()

//     spawn(fixed x, fixed y) {}

//     destroy() {}
// }

// let y = [
//     struct{
//         a = [
//             spawn EntityTest(10f, 10f),
//         ]
//     }
// ]

//let z = y[1].a[2].b.method1(false, true)